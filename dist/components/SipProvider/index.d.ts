import * as JsSIP from 'jssip';
import { AnswerOptions, RenegotiateOptions, RTCSession, TerminateOptions } from 'jssip/lib/RTCSession';
import { UnRegisterOptions } from 'jssip/lib/UA';
import * as PropTypes from 'prop-types';
import * as React from 'react';
import { CallDirection, CallStatus, SipErrorType, SipStatus } from '../../lib/enums';
import { ExtraHeaders } from '../../lib/types';
export interface JsSipConfig {
    socket: string;
    user: string;
    password: string;
    realm: string;
    host: string;
    port: number;
    pathname: string;
    secure: boolean;
    autoRegister: boolean;
    autoAnswer: boolean;
    iceRestart: boolean;
    sessionTimersExpires: number;
    extraHeaders: ExtraHeaders;
    iceServers: RTCIceServer[];
    debug: boolean;
    inboundAudioDeviceId: string;
    outboundAudioDeviceId: string;
    debugNamespaces?: string | null;
}
export interface JsSipState {
    sipStatus: SipStatus;
    sipErrorType: SipErrorType | null;
    sipErrorMessage: string | null;
    callStatus: CallStatus;
    callDirection: CallDirection | null;
    callCounterpart: string | null;
    dtmfSender: RTCDTMFSender | null;
    callIsOnHold: boolean;
    callMicrophoneIsMuted: boolean;
    rtcSession: RTCSession | null;
}
export default class SipProvider extends React.Component<JsSipConfig, JsSipState> {
    static childContextTypes: {
        sip: PropTypes.Requireable<PropTypes.InferProps<{
            status: PropTypes.Requireable<string>;
            errorType: PropTypes.Requireable<string>;
            errorMessage: PropTypes.Requireable<string>;
            host: PropTypes.Requireable<string>;
            port: PropTypes.Requireable<number>;
            user: PropTypes.Requireable<string>;
            pathname: PropTypes.Requireable<string>;
            secure: PropTypes.Requireable<boolean>;
            password: PropTypes.Requireable<string>;
            autoRegister: PropTypes.Requireable<boolean>;
            autoAnswer: PropTypes.Requireable<boolean>;
            sessionTimersExpires: PropTypes.Requireable<number>;
            extraHeaders: PropTypes.Requireable<{
                [x: string]: (string | null | undefined)[] | null | undefined;
            }>;
            iceServers: PropTypes.Requireable<(object | null | undefined)[]>;
            debug: PropTypes.Requireable<boolean>;
            debugNamespaces: PropTypes.Requireable<string>;
        }>>;
        call: PropTypes.Requireable<PropTypes.InferProps<{
            id: PropTypes.Requireable<string>;
            status: PropTypes.Requireable<string>;
            direction: PropTypes.Requireable<string>;
            counterpart: PropTypes.Requireable<string>;
            isOnHold: PropTypes.Requireable<boolean>;
            hold: PropTypes.Requireable<(...args: any[]) => any>;
            unhold: PropTypes.Requireable<(...args: any[]) => any>;
            toggleHold: PropTypes.Requireable<(...args: any[]) => any>;
            microphoneIsMuted: PropTypes.Requireable<boolean>;
            muteMicrophone: PropTypes.Requireable<(...args: any[]) => any>;
            unmuteMicrophone: PropTypes.Requireable<(...args: any[]) => any>;
            toggleMuteMicrophone: PropTypes.Requireable<(...args: any[]) => any>;
        }>>;
        registerSip: PropTypes.Requireable<(...args: any[]) => any>;
        unregisterSip: PropTypes.Requireable<(...args: any[]) => any>;
        answerCall: PropTypes.Requireable<(...args: any[]) => any>;
        startCall: PropTypes.Requireable<(...args: any[]) => any>;
        stopCall: PropTypes.Requireable<(...args: any[]) => any>;
        sendDTMF: PropTypes.Requireable<(...args: any[]) => any>;
        getUA: PropTypes.Requireable<(...args: any[]) => any>;
        audioSinkId: PropTypes.Requireable<string>;
        setAudioSinkId: PropTypes.Requireable<(...args: any[]) => any>;
    };
    static propTypes: {
        socket: PropTypes.Requireable<string>;
        user: PropTypes.Requireable<string>;
        password: PropTypes.Requireable<string>;
        realm: PropTypes.Requireable<string>;
        secure: PropTypes.Requireable<boolean>;
        autoRegister: PropTypes.Requireable<boolean>;
        autoAnswer: PropTypes.Requireable<boolean>;
        iceRestart: PropTypes.Requireable<boolean>;
        sessionTimersExpires: PropTypes.Requireable<number>;
        extraHeaders: PropTypes.Requireable<{
            [x: string]: (string | null | undefined)[] | null | undefined;
        }>;
        iceServers: PropTypes.Requireable<(object | null | undefined)[]>;
        debug: PropTypes.Requireable<boolean>;
        inboundAudioDeviceId: PropTypes.Requireable<string>;
        outboundAudioDeviceId: PropTypes.Requireable<string>;
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
    };
    static defaultProps: {
        host: null;
        port: null;
        pathname: string;
        secure: boolean;
        user: null;
        password: null;
        autoRegister: boolean;
        autoAnswer: boolean;
        iceRestart: boolean;
        sessionTimersExpires: number;
        extraHeaders: {
            register: never[];
            invite: never[];
            hold: never[];
        };
        iceServers: never[];
        debug: boolean;
        inboundAudioDeviceId: string;
        outboundAudioDeviceId: string;
        children: null;
    };
    private ua;
    private remoteAudio;
    private logger;
    private currentSinkId;
    private isPlaying;
    constructor(props: any);
    getChildContext(): {
        sip: {
            status: SipStatus;
            errorType: "sipErrorType/CONFIGURATION" | "sipErrorType/CONNECTION" | "sipErrorType/REGISTRATION" | null;
            errorMessage: string | null;
            socket: string;
            user: string;
            password: string;
            realm: string;
            host: string;
            port: number;
            pathname: string;
            secure: boolean;
            autoRegister: boolean;
            autoAnswer: boolean;
            iceRestart: boolean;
            sessionTimersExpires: number;
            extraHeaders: ExtraHeaders;
            iceServers: RTCIceServer[];
            debug: boolean;
            inboundAudioDeviceId: string;
            outboundAudioDeviceId: string;
            debugNamespaces?: string | null | undefined;
            children?: React.ReactNode;
        };
        call: {
            id: string;
            status: CallStatus;
            direction: "callDirection/INCOMING" | "callDirection/OUTGOING" | null;
            counterpart: string | null;
            dtmfSender: RTCDTMFSender | null;
            isOnHold: boolean;
            hold: any;
            unhold: any;
            toggleHold: any;
            microphoneIsMuted: boolean;
            muteMicrophone: any;
            unmuteMicrophone: any;
            toggleMuteMicrophone: any;
            renegotiate: any;
        };
        registerSip: any;
        unregisterSip: any;
        audioSinkId: string;
        setAudioSinkId: (sinkId: string) => Promise<void>;
        answerCall: any;
        startCall: any;
        stopCall: any;
        sendDTMF: any;
        getUA: any;
    };
    getUA(): JsSIP.UA | null;
    getUAOrFail(): JsSIP.UA;
    getAudioElement(): HTMLAudioElement | null;
    componentDidMount(): void;
    componentDidUpdate(prevProps: any): void;
    componentWillUnmount(): void;
    deleteRemoteAudio(): void;
    registerSip(): void;
    unregisterSip(options?: UnRegisterOptions): void;
    answerCall: (options?: AnswerOptions | undefined) => void;
    startCall: (destination: string | number, anonymous?: boolean | undefined) => void;
    stopCall: (options?: TerminateOptions | undefined) => void;
    sendDTMF: (tones: string, duration?: number, interToneGap?: number) => void;
    reconfigureDebug(): void;
    setAudioSinkId: (sinkId: string) => Promise<void>;
    get audioSinkId(): string;
    reinitializeJsSIP(): Promise<void>;
    private handleAutoAnswer;
    render(): React.ReactNode;
    callHold: (useUpdate?: boolean) => void;
    renegotiate: (options?: RenegotiateOptions | undefined, done?: (() => void) | undefined) => void;
    callUnhold: (useUpdate?: boolean) => void;
    callToggleHold: (useUpdate?: boolean) => void;
    callMuteMicrophone: () => void;
    callUnmuteMicrophone: () => void;
    callToggleMuteMicrophone: () => void;
    private getRemoteAudioOrFail;
    private createRemoteAudioElement;
}
